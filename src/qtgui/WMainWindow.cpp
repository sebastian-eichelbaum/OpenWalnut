//---------------------------------------------------------------------------
//
// Project: OpenWalnut ( http://www.openwalnut.org )
//
// Copyright 2009 OpenWalnut Community, BSV@Uni-Leipzig and CNCF@MPI-CBS
// For more information see http://www.openwalnut.org/copying
//
// This file is part of OpenWalnut.
//
// OpenWalnut is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// OpenWalnut is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with OpenWalnut. If not, see <http://www.gnu.org/licenses/>.
//
//---------------------------------------------------------------------------

#include <iostream>
#include <map>
#include <string>
#include <vector>

#include <boost/thread.hpp>
#include <boost/regex.hpp>
#include <boost/filesystem.hpp>

#include <QApplication>
#include <QCloseEvent>
#include <QDockWidget>
#include <QFileDialog>
#include <QIcon>
#include <QMenu>
#include <QMenuBar>
#include <QMessageBox>
#include <QTextEdit>
#include <QShortcut>
#include <QSlider>
#include <QVBoxLayout>
#include <QWidget>
#include <QtCore/QSettings>
#include <QtCore/QUrl>
#include <QInputDialog>

#include <QWebView>

#include "core/WVersion.h"   // NOTE: this file is auto-generated by CMAKE

#include "controlPanel/WPropertyBoolWidget.h"
#include "controlPanel/WQtControlPanel.h"
#include "core/common/WColor.h"
#include "core/common/WIOTools.h"
#include "core/common/WPathHelper.h"
#include "core/common/WProjectFileIO.h"
#include "core/dataHandler/WDataHandler.h"
#include "core/dataHandler/WDataSetFibers.h"
#include "core/dataHandler/WDataSetSingle.h"
#include "core/dataHandler/WDataSetPoints.h"
#include "core/dataHandler/WEEG2.h"
#include "core/graphicsEngine/WGEZoomTrackballManipulator.h"
#include "core/graphicsEngine/WROIBox.h"
#include "core/kernel/WDataModule.h"
#include "core/kernel/WKernel.h"
#include "core/kernel/WModule.h"
#include "core/kernel/WModuleFactory.h"
#include "core/kernel/WModuleCombiner.h"
#include "core/kernel/WModuleCombinerTypes.h"
#include "core/kernel/WDataModuleInputFilterFile.h"
#include "core/kernel/WProjectFile.h"
#include "core/kernel/WROIManager.h"
#include "core/kernel/WSelectionManager.h"
#include "events/WEventTypes.h"
#include "events/WDeferredCallEvent.h"
#include "events/WModuleCrashEvent.h"
#include "events/WModuleReadyEvent.h"
#include "events/WModuleRemovedEvent.h"
#include "events/WLoadFinishedEvent.h"
#include "events/WLogEvent.h"
#include "guiElements/WQtPropertyBoolAction.h"
#include "abstractUI/WUIQtWidgetBase.h"
#include "WQtMessagePopup.h"
#include "WQtGui.h"
#include "WQtCombinerToolbar.h"
#include "WQtGLDockWidget.h"
#include "WQtNavGLWidget.h"
#include "WSettingAction.h"
#include "WSettingMenu.h"
#include "WQtMessageDialog.h"

#include "WMainWindow.h"

WMainWindow::WMainWindow( QSplashScreen* splash ):
    QMainWindow(),
    m_splash( splash ),
    m_currentCompatiblesToolbar( NULL ),
    m_iconManager(),
    m_closeFirstStage( false ),
    m_closeInProgress( false )
{
    setAcceptDrops( true ); // enable drag and drop events
}

WMainWindow::~WMainWindow()
{
    // cleanup
}

/**
 * Create a distinct separator.
 *
 * \param parent the parent
 *
 * \return the separator
 */
QAction* createSeperator( QWidget* parent )
{
    QAction* separator = new QAction( parent );
    separator->setSeparator( true );
    return separator;
}

void WMainWindow::setupGUI()
{
    wlog::info( "WMainWindow" ) << "Setting up GUI";

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Setting setup
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    WSettingAction* hideMenuAction = new WSettingAction( this, "qtgui/showMenu",
                                                               "Show Menubar",
                                                               "Allows you to hide the menu. Can be restored using CTRL-M.",
                                                               true,
                                                               false,
                                                               QKeySequence( Qt::CTRL + Qt::Key_M ) );

    WSettingAction* showNavWidgets = new WSettingAction( this, "qtgui/showNavigationWidgets",
                                                               "Show Navigation Views",
                                                               "Disables the navigation views completely. This can lead to a speed-up and is "
                                                               "recommended for those who do not need them.",
                                                               false,
                                                               true    // this requires a restart
                                                       );
    m_sliderMinMaxEditSetting = new WSettingAction( this, std::string( "qtgui/" ) +  std::string( "sliderMinMaxEdit" ),
                                                    "Slider Min/Max Editing",
                                                    "If enabled, the maximum and minimum values of slider can be edited.",
                                                    false );

    WSettingAction* mtViews = new WSettingAction( this, "qtgui/ge/multiThreadedViewer",
                                                        "Multi-Threaded Views",
                                                        "If enabled, the graphic windows are rendered in different threads. This can speed-up "
                                                        "rendering on machines with multiple cores. WARNING: can lead to crashes sometimes.",
                                                        false,
                                                        true // require restart
                                                );
    // NOTE: the multi-threading feature needs to be activated BEFORE the first viewer is created. To ensure this we do it here.
    WGraphicsEngine::getGraphicsEngine()->setMultiThreadedViews( mtViews->get() );

    // set the log-level setting.
    // NOTE: see WQtGui which reads the setting.
    QList< QString > logOptions;
    logOptions.push_back( "Debug" );
    logOptions.push_back( "Info" );
    logOptions.push_back( "Warning" );
    logOptions.push_back( "Error" );
    WSettingMenu* logLevels = new WSettingMenu( this, "qtgui/logLevel",
                                                      "Log-Level",
                                                      "Allows one to set the log verbosity.",
                                                      1,    // info is the default
                                                      logOptions
                                              );
    connect( logLevels, SIGNAL( change( unsigned int ) ), this, SLOT( handleLogLevelUpdate( unsigned int ) ) );

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // GUI setup
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // We need several icons later in the GUI. Build some mappings:
    m_iconManager.addMapping( "logo", "openwalnut" );
    m_iconManager.addMapping( "axial icon", "orientation_axial" );
    m_iconManager.addMapping( "coronal icon", "orientation_coronal" );
    m_iconManager.addMapping( "sagittal icon", "orientation_sagittal" );
    m_iconManager.addMapping( "DefaultModuleIcon", "default" );
    m_iconManager.addMapping( "missingModule", "question" );
    m_iconManager.addMapping( "view", "camera" );
    m_iconManager.addMapping( "moduleCrashed", "error" );
    m_iconManager.addMapping( "moduleBusy", "busy" );
    m_iconManager.addMapping( "saveProject", "save" );
    m_iconManager.addMapping( "newProject", "new" );

    if( objectName().isEmpty() )
    {
        setObjectName( QString::fromUtf8( "MainWindow" ) );
    }

    // NOTE: this only is an initial size. The state reloaded from QSettings will set it to the value the user had last session.
    resize( 1024, 768 );
    setWindowIcon( m_iconManager.getIcon( "logo" ) );
    std::string windowHeading =  std::string( "OpenWalnut " ) + std::string( W_VERSION );
    setWindowTitle( QString::fromStdString( windowHeading ) );

    setDockOptions( QMainWindow::AnimatedDocks |  QMainWindow::AllowNestedDocks | QMainWindow::AllowTabbedDocks );

    //network Editor
    m_networkEditor = NULL;
    m_networkEditor = new WQtNetworkEditor( this );
    m_networkEditor->setFeatures( QDockWidget::AllDockWidgetFeatures );

    // strangely, the QGraphics* objects do not properly forward drag/drop events. We need to explicitly handle them.
    connect( m_networkEditor->getView(), SIGNAL( dragDrop( QDropEvent* ) ),
             this, SLOT( handleDrop( QDropEvent* ) ) );

    // the control panel instance is needed for the menu
    m_controlPanel = new WQtControlPanel( this );
    m_controlPanel->setFeatures( QDockWidget::AllDockWidgetFeatures );
    m_controlPanel->addSubject( "Default Subject" );

    // add all docks
    addDockWidget( Qt::RightDockWidgetArea, m_controlPanel->getModuleDock() );
    if( m_networkEditor )
    {
        addDockWidget( Qt::RightDockWidgetArea, m_networkEditor );
    }

    addDockWidget( Qt::RightDockWidgetArea, m_controlPanel->getColormapperDock() );
    addDockWidget( Qt::RightDockWidgetArea, m_controlPanel->getRoiDock() );

    // the message dock:
    m_messageDock = new WQtMessageDock( "Messages", this );
    addDockWidget( Qt::RightDockWidgetArea, m_messageDock );

    // tabify those panels by default
    if( m_networkEditor )
    {
        tabifyDockWidget( m_networkEditor, m_controlPanel->getModuleDock() );
    }
    tabifyDockWidget( m_controlPanel->getModuleDock(), m_controlPanel->getColormapperDock() );
    tabifyDockWidget( m_controlPanel->getColormapperDock(), m_controlPanel->getRoiDock() );
    tabifyDockWidget( m_controlPanel->getRoiDock(), m_messageDock );

    m_glDock = new QMainWindow();
    m_glDock->setObjectName( "GLDock" );
    m_glDock->setDockOptions( QMainWindow::AnimatedDocks |  QMainWindow::AllowNestedDocks | QMainWindow::AllowTabbedDocks );
    m_glDock->setDocumentMode( true );
    setCentralWidget( m_glDock );

    m_mainGLDock = new WQtGLDockWidget( "Main View", "3D View", m_glDock );
    // activate effects for this view by default
    m_mainGLDock->getGLWidget()->getViewer()->setEffectsActiveDefault();
    m_mainGLDock->getGLWidget()->setSizePolicy( QSizePolicy::Expanding, QSizePolicy::Expanding );
    m_mainGLDock->restoreSettings();
    m_mainGLWidget = m_mainGLDock->getGLWidget();
    m_glDock->addDockWidget( Qt::LeftDockWidgetArea, m_mainGLDock );
    connect( m_mainGLWidget, SIGNAL( renderedFirstFrame() ), this, SLOT( handleGLVendor() ) );

    addDockWidget( Qt::RightDockWidgetArea, m_controlPanel );

    // by default, the module editor should be in front
    if( m_networkEditor )
    {
        m_networkEditor->raise();
    }
    else
    {
        m_controlPanel->getModuleDock()->raise();
    }

    // NOTE: we abuse the gl widgets first frame event to handle startup news.
    connect( m_mainGLWidget, SIGNAL( renderedFirstFrame() ), this, SLOT( handleStartMessages() ) );
    connect( m_mainGLWidget, SIGNAL( renderedFirstFrame() ), this, SLOT( closeSplash() ) );

    m_permanentToolBar = new WQtToolBar( "Standard Toolbar", this );
    addToolBar( Qt::TopToolBarArea, m_permanentToolBar );

    // math: Due to the OLD issue 406 resp.
    // http://stackoverflow.com/questions/31983269/how-to-identify-a-certain-qt-widget
    // There might be a white box, on Apple Mac OSX only, which sometimes hides the window buttons
    // for maximization, minimization and closing. This is extremely disturbing, hence, we leave them
    // visible as a default. I know this fixes only the symptom, but not the origin, but I've searched
    // some days by now and couldn't find anything. I will describe all I found so far in the ticket 406.
    #ifndef W_OS_OSX
        m_permanentToolBar->setVisible( false );
    #else
        m_permanentToolBar->setVisible( true );
    #endif

    m_loadButton = new QAction( m_iconManager.getIcon( "load" ), "Load Dataset or Project", m_permanentToolBar );
    m_loadButton->setShortcut( QKeySequence(  QKeySequence::Open ) );
    QAction* roiButton = new QAction( m_iconManager.getIcon( "add_roi" ), "ROI", m_permanentToolBar );
    m_saveAction = new QAction( m_iconManager.getIcon( "saveProject" ), "Save Project", m_permanentToolBar );

    connect( m_loadButton, SIGNAL(  triggered( bool ) ), this, SLOT( openLoadDialog() ) );
    connect( roiButton, SIGNAL(  triggered( bool ) ), this, SLOT( newRoi() ) );
    connect( m_saveAction, SIGNAL( triggered( bool ) ), this, SLOT( projectSaveAll() ) );

    m_loadButton->setToolTip( "Load a dataset or project from file" );
    roiButton->setToolTip( "Insert a new ROI" );
    m_saveAction->setToolTip( "Save current project to file" );

    // we want the upper most tree item to be selected. This helps to make the always compatible modules
    // show up in the tool bar from the beginning. And ... it doesn't hurt.
    m_controlPanel->selectUpperMostEntry();

    // NOTE: Please be aware that not every menu needs a shortcut key. If you add a shortcut, you should use one of the
    // QKeySequence::StandardKey defaults and avoid ambiguities like Ctrl-C for the configure dialog is not the best choice as Ctrl-C, for the
    // most users is the Copy shortcut.

    m_menuBar = new QMenuBar( this );

    // hide menu?
    m_menuBar->setVisible( hideMenuAction->get() );
    connect( hideMenuAction, SIGNAL( change( bool ) ), m_menuBar, SLOT( setVisible( bool ) ) );
    addAction( hideMenuAction );

    QMenu* fileMenu = m_menuBar->addMenu( "File" );

    m_newAction = fileMenu->addAction( m_iconManager.getIcon( "newProject" ),
                                       "New Project",
                                       this,
                                       SLOT( newProject() ),
                                       QKeySequence( Qt::CTRL + Qt::Key_N ) );
    fileMenu->addAction( m_loadButton );
    m_saveMenu = fileMenu->addMenu( m_iconManager.getIcon( "saveProject" ), "Save Project" );
    m_saveMenu->addAction( "Save Project", this, SLOT( projectSaveAll() ), QKeySequence::Save );
    m_saveMenu->addAction( "Save Modules Only", this, SLOT( projectSaveModuleOnly() ) );
    m_saveMenu->addAction( "Save Camera Only", this, SLOT( projectSaveCameraOnly() ) );
    // saveMenu->addAction( "Save ROIs Only", this, SLOT( projectSaveROIOnly() ) );
    m_saveAction->setMenu( m_saveMenu );

    fileMenu->addSeparator();
    m_quitAction = fileMenu->addAction( m_iconManager.getIcon( "quit" ), "Quit", this, SLOT( close() ), QKeySequence( QKeySequence::Quit ) );

    // This QAction stuff is quite ugly and complicated some times ... There is no nice constructor which takes name, slot keysequence and so on
    // directly -> set shortcuts, and some further properties using QAction's interface

    m_settingsAction = new QAction( "Settings", this );
    m_settingsAction->setIcon( m_iconManager.getIcon( "configure" ) );
    m_settingsMenu = m_menuBar->addMenu( "Settings" );
    m_viewMenu = m_settingsMenu->addMenu( "View" );
    m_viewMenu->addAction( hideMenuAction );
    m_viewMenu->addSeparator();
    m_viewMenu->addAction( showNavWidgets );
    m_viewMenu->addSeparator();
    m_viewMenu->addMenu( m_permanentToolBar->getStyleMenu() );
    m_settingsMenu->addAction( m_sliderMinMaxEditSetting );
    m_settingsMenu->addAction( m_controlPanel->getModuleConfig().getConfigureAction() );
    m_settingsMenu->addSeparator();
    m_settingsMenu->addAction( mtViews );
    m_settingsMenu->addSeparator();
    m_settingsMenu->addMenu( logLevels );
    m_settingsMenu->addSeparator();
    m_settingsAction->setMenu( m_settingsMenu );

    QAction* controlPanelTrigger = m_controlPanel->toggleViewAction();
    QList< QKeySequence > controlPanelShortcut;
    controlPanelShortcut.append( QKeySequence( Qt::Key_F9 ) );
    controlPanelTrigger->setShortcuts( controlPanelShortcut );
    this->addAction( controlPanelTrigger );  // this enables the action even if the menu bar is invisible

    m_helpAction = new QAction( "Help", this );
    m_helpAction->setIcon( m_iconManager.getIcon( "questionmark" ) );
    connect( m_helpAction, SIGNAL( triggered() ), this, SLOT( openOpenWalnutHelpDialog() ) );
    m_helpMenu = m_menuBar->addMenu( "Help" );
    m_helpMenu->addAction( m_iconManager.getIcon( "logo" ), "Welcome to OpenWalnut", this, SLOT( showWelcomeDialog() ) );
    m_helpMenu->addAction( m_iconManager.getIcon( "help" ), "OpenWalnut Help", this, SLOT( openOpenWalnutHelpDialog() ),
                           QKeySequence( QKeySequence::HelpContents ) );
    m_helpMenu->addSeparator();
    m_helpMenu->addAction( m_iconManager.getIcon( "logo" ), "About OpenWalnut", this, SLOT( openAboutDialog() ) );
    m_helpMenu->addAction(  m_iconManager.getIcon( "qt" ), "About Qt", this, SLOT( openAboutQtDialog() ) );
    m_helpAction->setMenu( m_helpMenu );
    connect( m_helpAction, SIGNAL( triggered( bool ) ), this, SLOT( openOpenWalnutHelpDialog() ) );

    setMenuBar( m_menuBar );

    // initially 3 navigation views
    {
        if( showNavWidgets->get() )
        {
            m_navAxial = boost::shared_ptr< WQtNavGLWidget >( new WQtNavGLWidget( "Axial View", "Axial View", this, "Axial Slice",
                                                                                  m_mainGLWidget ) );
            m_navAxial->setFeatures( QDockWidget::AllDockWidgetFeatures );
            m_navAxial->setSliderProperty( WKernel::getRunningKernel()->getSelectionManager()->getPropAxialPos() );
            m_navAxial->getGLWidget()->setCameraManipulator( WQtGLWidget::NO_OP );

            addDockWidget( Qt::LeftDockWidgetArea, m_navAxial.get(), Qt::Vertical );

            m_navCoronal = boost::shared_ptr< WQtNavGLWidget >( new WQtNavGLWidget( "Coronal View", "Coronal View", this, "Coronal Slice",
                                                                                    m_mainGLWidget ) );
            m_navCoronal->setFeatures( QDockWidget::AllDockWidgetFeatures );
            m_navCoronal->setSliderProperty( WKernel::getRunningKernel()->getSelectionManager()->getPropCoronalPos() );
            m_navCoronal->getGLWidget()->setCameraManipulator( WQtGLWidget::NO_OP );

            addDockWidget( Qt::LeftDockWidgetArea, m_navCoronal.get(), Qt::Vertical );

            m_navSagittal =
                boost::shared_ptr< WQtNavGLWidget >( new WQtNavGLWidget( "Sagittal View", "Sagittal View", this, "Sagittal Slice",
                                                                         m_mainGLWidget ) );
            m_navSagittal->setFeatures( QDockWidget::AllDockWidgetFeatures );
            m_navSagittal->setSliderProperty( WKernel::getRunningKernel()->getSelectionManager()->getPropSagittalPos() );
            m_navSagittal->getGLWidget()->setCameraManipulator( WQtGLWidget::NO_OP );

            addDockWidget( Qt::LeftDockWidgetArea, m_navSagittal.get(), Qt::Vertical );
        }
    }

    // create the show/hide actions using the selection manager's props
    WQtPropertyBoolAction* showAxial = new WQtPropertyBoolAction( WKernel::getRunningKernel()->getSelectionManager()->getPropAxialShow(),
                                                                  m_permanentToolBar );
    showAxial->setToolTip( "Toggle axial slice" );
    showAxial->setText( "Toggle Axial Slice" );
    showAxial->setIcon( m_iconManager.getIcon( "axial icon" ) );

    WQtPropertyBoolAction* showCoronal = new WQtPropertyBoolAction( WKernel::getRunningKernel()->getSelectionManager()->getPropCoronalShow(),
                                                                    m_permanentToolBar );
    showCoronal->setToolTip( "Toggle coronal slice" );
    showCoronal->setText( "Toggle Coronal Slice" );
    showCoronal->setIcon( m_iconManager.getIcon( "coronal icon" ) );

    WQtPropertyBoolAction* showSagittal = new WQtPropertyBoolAction( WKernel::getRunningKernel()->getSelectionManager()->getPropSagittalShow(),
                                                                     m_permanentToolBar );
    showSagittal->setToolTip( "Toggle sagittal slice" );
    showSagittal->setText( "Toggle Sagittal Slice" );
    showSagittal->setIcon( m_iconManager.getIcon( "sagittal icon" ) );

    // setup permanent toolbar
    m_permanentToolBar->addAction( m_newAction );
    m_permanentToolBar->addAction( m_loadButton );
    m_permanentToolBar->addAction( m_saveAction );
    m_permanentToolBar->addSeparator();
    m_permanentToolBar->addAction( roiButton );
    m_permanentToolBar->addSeparator();
    m_permanentToolBar->addAction( showAxial );
    m_permanentToolBar->addAction( showCoronal );
    m_permanentToolBar->addAction( showSagittal );
    m_permanentToolBar->addSeparator();

    // set the according actions to the toolbars
    m_networkEditor->addTitleAction( m_newAction );
    m_networkEditor->addTitleAction( m_loadButton );
    m_networkEditor->addTitleAction( m_saveAction );
    m_networkEditor->addTitleSeperator();
    m_networkEditor->addTitleAction( m_settingsAction, true );
    m_networkEditor->addTitleAction( m_helpAction, true );

    // allow the control panel to complete setup
    m_controlPanel->completeGuiSetup();

    // add the roi actions to roi dock title
    m_controlPanel->getRoiDock()->addTitleAction( roiButton );
    m_controlPanel->getRoiDock()->addTitleAction( m_controlPanel->getRoiDeleteAction() );

    // after creating the GUI, restore its saved state
    restoreSavedState();

    // this ensures that there is always at least the main window visible. Removing this might cause a freeze on startup if the user has closed
    // all gl widgets during the last session.
    m_mainGLDock->setVisible( true );
}

void WMainWindow::autoAdd( boost::shared_ptr< WModule > module, std::string proto, bool onlyOnce )
{
    // if only one module should be added, and there already is one --- skip.
    if( onlyOnce && !WKernel::getRunningKernel()->getRootContainer()->getModules( proto ).empty() )
    {
        return;
    }

    // get the prototype.
    if( !WKernel::getRunningKernel()->getRootContainer()->applyModule( module, proto, true ) )
    {
        WLogger::getLogger()->addLogMessage( "Auto Display active but module " + proto + " could not be added.",
                                             "GUI", LL_ERROR );
    }
}

void WMainWindow::moduleSpecificCleanup( boost::shared_ptr< WModule > /* module */ )
{
    // called for each removed module. Use this to undo modifications done due to added modules (moduleSpecificSetup)
}

void WMainWindow::moduleSpecificSetup( boost::shared_ptr< WModule > /* module */ )
{
    // Add all special handlings here. This method is called whenever a module is marked "ready". You can set up the gui for special modules,
    // load certain modules for datasets and so on.

    // The Data Modules also play an special role. To have modules being activated when certain data got loaded, we need to hook it up here.
    // NOTE: Auto Display is currently disabled.
    /*bool useAutoDisplay = m_autoDisplaySetting->get();
    if( useAutoDisplay && module->getType() == MODULE_DATA )
    {
        WLogger::getLogger()->addLogMessage( "Auto Display active and Data module added. The proper module will be added.",
                                             "GUI", LL_DEBUG );

        // data modules contain an member denoting the real data type. Currently we only have one data module and a not very modulated data
        // structures.
        boost::shared_ptr< WDataModule > dataModule = boost::static_pointer_cast< WDataModule >( module );

        // grab data and identify type
        if( dataModule->getDataSet()->isA< WDataSetSingle >() && dataModule->getDataSet()->isTexture() )
        {
            // it is a dataset single
            // load a nav slice module if a WDataSetSingle is available!?
            autoAdd( module, "Navigation Slices", true );
        }
        else if( dataModule->getDataSet()->isA< WDataSetFibers >() )
        {
            // it is a fiber dataset -> add the FiberDisplay module
            autoAdd( module, "Fiber Display" );
        }
        else if( dataModule->getDataSet()->isA< WEEG2 >() )
        {
            // it is a eeg dataset -> add the eegView module
            autoAdd( module, "EEG View" );
        }
        else if( dataModule->getDataSet()->isA< WDataSetPoints >() )
        {
            // it is a point dataset -> add the point render module
            autoAdd( module, "Point Renderer" );
        }
    }*/
}

void WMainWindow::setCompatiblesToolbar( WQtCombinerToolbar* toolbar )
{
    if( m_currentCompatiblesToolbar )
    {
        delete m_currentCompatiblesToolbar;
    }
    m_currentCompatiblesToolbar = toolbar;

    if( !toolbar )
    {
        // ok, reset the toolbar
        // So create a dummy to permanently reserve the space
        m_currentCompatiblesToolbar = new WQtCombinerToolbar( this );
    }

    // we want to keep the tool-button styles in sync
    m_currentCompatiblesToolbar->setToolButtonStyle( m_permanentToolBar->toolButtonStyle() );
    connect( m_permanentToolBar, SIGNAL( toolButtonStyleChanged( Qt::ToolButtonStyle ) ),
             m_currentCompatiblesToolbar, SLOT( setToolButtonStyle( Qt::ToolButtonStyle ) ) );

    // and the position of the toolbar
    // math: Due to the OLD issue 406 resp.
    // http://stackoverflow.com/questions/31983269/how-to-identify-a-certain-qt-widget
    // There might be a white box, on Apple Mac OSX only, which sometimes hides the window buttons
    // for maximization, minimization and closing. This is extremely disturbing, hence, we leave them
    // visible as a default. I know this fixes only the symptom, but not the origin, but I've searched
    // some days by now and couldn't find anything. I will describe all I found so far in the ticket 406.
    #ifndef W_OS_OSX
        toolbar->setVisible( false );
    #else
        toolbar->setVisible( true );
    #endif

    addToolBar( Qt::TopToolBarArea, m_currentCompatiblesToolbar );
}

WQtCombinerToolbar* WMainWindow::getCompatiblesToolbar()
{
    return m_currentCompatiblesToolbar;
}

WQtControlPanel* WMainWindow::getControlPanel()
{
    return m_controlPanel;
}

WQtNetworkEditor* WMainWindow::getNetworkEditor()
{
    return m_networkEditor;
}

bool WMainWindow::projectSave( const std::vector< boost::shared_ptr< WProjectFileIO > >& writer )
{
    QString lastPath = WQtGui::getSettings().value( "LastProjectSavePath", "" ).toString();
    QString selected = QFileDialog::getSaveFileName( this, "Save Project as", lastPath,
                                                     "Project File (*.owproj *.owp)" );
    if( selected == "" )
    {
        return false;
    }

    // extract path and save to settings
    boost::filesystem::path p( selected.toStdString() );
    WQtGui::getSettings().setValue( "LastProjectSavePath", QString::fromStdString( p.parent_path().string() ) );

    bool success = true;
    std::string filename = ( selected ).toStdString();

    // append owp if suffix is not present, yet
    if( filename.rfind( ".owp" ) != filename.size() - 4
     && filename.rfind( ".owproj" ) != filename.size() - 7 )
    {
        filename += ".owp";
    }

    boost::shared_ptr< WProjectFile > proj = boost::shared_ptr< WProjectFile >(
            new WProjectFile( filename )
    );

    try
    {
        // This call is synchronous.
        if( writer.empty() )
        {
            proj->save();
        }
        else
        {
            proj->save( writer );
        }
    }
    catch( const std::exception& e )
    {
        QString title = "Problem while saving project file.";
        QString message = "<b>Problem while saving project file.</b><br/><br/><b>File:  </b>" + selected +
                          "<br/><b>Message:  </b>" + QString::fromStdString( e.what() );
        QMessageBox::critical( this, title, message );
        success = false;
    }
    return success;
}

bool WMainWindow::projectSaveAll()
{
    std::vector< boost::shared_ptr< WProjectFileIO > > w;
    // an empty list equals "all"
    return projectSave( w );
}

bool WMainWindow::projectSaveCameraOnly()
{
    std::vector< boost::shared_ptr< WProjectFileIO > > w;
    w.push_back( WProjectFile::getCameraWriter() );
    return projectSave( w );
}

bool WMainWindow::projectSaveROIOnly()
{
    std::vector< boost::shared_ptr< WProjectFileIO > > w;
    w.push_back( WProjectFile::getROIWriter() );
    return projectSave( w );
}

bool WMainWindow::projectSaveModuleOnly()
{
    std::vector< boost::shared_ptr< WProjectFileIO > > w;
    w.push_back( WProjectFile::getModuleWriter() );
    return projectSave( w );
}

void WMainWindow::newProject()
{
    WKernel::getRunningKernel()->getRootContainer()->removeAll();
    WDataHandler::getDataHandler()->clear();
}

QString collectFilters()
{
    QString result;
    QString all;

    // add all the filters the data modules provide
    std::vector< WDataModule::SPtr > dataModules = WModuleFactory::getModuleFactory()->getPrototypesByType< WDataModule >();

    for( std::vector< WDataModule::SPtr >::const_iterator iter = dataModules.begin(); iter != dataModules.end(); ++iter )
    {
        std::vector< WDataModuleInputFilter::ConstSPtr > filters = ( *iter )->getInputFilter();
        for( std::vector< WDataModuleInputFilter::ConstSPtr >::const_iterator filterIter = filters.begin(); filterIter != filters.end();
                ++filterIter )
        {
            WDataModuleInputFilterFile::ConstSPtr ff = boost::dynamic_pointer_cast< const WDataModuleInputFilterFile >( *filterIter );
            if( ff )
            {
                QString description = QString::fromStdString( ff->getDescription() );
                QString extension = QString::fromStdString( ff->getExtension() );
                all += QString( " *." ) + extension;
                result += description + QString( "(*." ) + extension + QString( ");;" );
            }
        }
    }

    // Project files:
    all += QString( " *.owp *.owproj" );
    result += QString( "Project File (*.owp *.owproj );;" );

    // Interpreter files.
    for( std::size_t k = 0; k < WKernel::getRunningKernel()->getScriptEngine()->getNumInterpreters(); ++k )
    {
        QString description = QString::fromStdString( WKernel::getRunningKernel()->getScriptEngine()->getInterpreter( k )->getName() );
        // NOTE: unlike above, this already contains the "."
        QString extension = QString::fromStdString( WKernel::getRunningKernel()->getScriptEngine()->getInterpreter( k )->getExtension() );
        all += QString( " *" ) + extension;
        result += description + QString( "(*" ) + extension + QString( ");;" );
    }

    // math: on 11. Aug. 2015, related old issues 404
    // The following #ifdef is due to the following QT-Bug: https://bugreports.qt.io/browse/QTBUG-38303
    // Hence, we use any file as known file type for MAC OSX only.
    #ifdef Q_OS_OSX
        return QString( "Known file types (* " ) + all  + QString( ");;" ) + result;
    #else
        return QString( "Known file types (" ) + all + QString( ");;" ) + result;
    #endif
}

void WMainWindow::openLoadDialog()
{
    QString lastPath = WQtGui::getSettings().value( "LastOpenPath", "" ).toString();

    // build filter list
    // NOTE: Qt Doc says we need to separate multiple filters by ";;"
    QString filters = collectFilters();
    // add extensions of script files
    filters += QString( "Any files (*)" );

    QStringList filenames = QFileDialog::getOpenFileNames( this, "Open Data, Project or Script", lastPath, filters );
    if( filenames.empty() )
    {
        return;
    }

    // extract path and save to settings
    boost::filesystem::path p( filenames[0].toStdString() );
    WQtGui::getSettings().setValue( "LastOpenPath", QString::fromStdString( p.parent_path().string() ) );

    std::vector< std::string > loadDataFilenames;
    QStringList::const_iterator constIterator;
    for( constIterator = filenames.constBegin(); constIterator != filenames.constEnd(); ++constIterator )
    {
        boost::filesystem::path fn( ( *constIterator ).toLocal8Bit().constData() );
        std::string suffix = getSuffix( fn );

        // is this a project file?
        if( ( suffix == ".owp" ) || ( suffix == ".owproj" ) )
        {
            asyncProjectLoad( fn.string() );
        }
        else
        {
            // this is not a project. So we assume it is a data file or script
            boost::shared_ptr< WScriptInterpreter > scriptInterpreter =
                    WKernel::getRunningKernel()->getScriptEngine()->getInterpreterByFileExtension( suffix );

            if( scriptInterpreter )
            {
                scriptInterpreter->executeFileAsync( fn.string() );
            }
            else
            {
                loadDataFilenames.push_back( fn.string() );
            }
        }
    }

    m_loaderSignal( loadDataFilenames );
}

void WMainWindow::asyncProjectLoad( std::string filename )
{
    WProjectFile::SPtr proj( new WProjectFile( filename, boost::bind( &WMainWindow::slotLoadFinished, this, _1, _2, _3 ) ) );
    proj->load();
}

void WMainWindow::slotLoadFinished( boost::filesystem::path file, std::vector< std::string > errors, std::vector< std::string > warnings )
{
    // as this function might be called from outside the gui thread, use an event:
    QCoreApplication::postEvent( this, new WLoadFinishedEvent( file, errors, warnings ) );

    if( errors.size() )
    {
        wlog::warn( "MainWindow" ) << "Async load error occurred. Informing user.";
    }
}

void WMainWindow::openAboutQtDialog()
{
    QMessageBox::aboutQt( this, "About Qt" );
}

void WMainWindow::openAboutDialog()
{
    std::string filename( WPathHelper::getDocPath().string() + "/openwalnut-qt/OpenWalnutAbout.html" );
    std::string content = readFileIntoString( filename );
    std::string windowHeading =  std::string( "About OpenWalnut " ) + std::string( W_VERSION );
    QMessageBox::about( this, windowHeading.c_str(), content.c_str() );
}

void WMainWindow::openOpenWalnutHelpDialog()
{
    std::string filename( WPathHelper::getDocPath().string() + "/openwalnut-qt/OpenWalnutHelp.html" );

    std::string content = readFileIntoString( filename );

    QWidget* window = new QWidget( this, Qt::Window );
    window->setWindowTitle( "OpenWalnut Help" );
    // specify intial layout
    QVBoxLayout *layout = new QVBoxLayout( window );
    window->setLayout( layout );
    window->resize( 500, 500 );

    window->show();

    QWebView *view = new QWebView( this );
    QString location( QString( "file://" ) + WPathHelper::getDocPath().string().c_str() + "/openwalnut-qt/" );
    view->setHtml( content.c_str(), QUrl( location  ) );
    view->show();
    layout->addWidget( view );
}

void WMainWindow::openNotImplementedDialog()
{
    QMessageBox::information( this, "Not yet implemented!",
                              "This functionality is planned for future versions of OpenWalnut. "
                              "It is not yet implemented." );
}

boost::signals2::signal< void( std::vector< std::string > ) >* WMainWindow::getLoaderSignal()
{
    return &m_loaderSignal;
}

WIconManager*  WMainWindow::getIconManager()
{
    return &m_iconManager;
}

void WMainWindow::closeStage1Thread()
{
    WKernel::getRunningKernel()->finalize();

    // close all registered custom widgets -> modules might have missed them.
    // But first, we need to copy the custom widget list as the close function of the custom widgets modifies this list
    CustomWidgets copy;
    {
        WSharedSequenceContainer< CustomWidgets >::ReadTicket r = m_customWidgets.getReadTicket();
        copy = r->get();
        // IMPORTANT: free lock
    }

    // close all of them now
    for( CustomWidgets::iterator it = copy.begin(); it != copy.end(); ++it )
    {
        wlog::warn( "MainWindow" ) << "Closing custom UI widget \"" << ( *it )->getTitleQString().toStdString() << "\". This should have be"
                                      " done by the owning module!";
        ( *it )->close();
    }
    copy.clear();

    // notify main window -> just call close() again with updated state
    WQtGui::execInGUIThreadAsync( boost::bind( &WMainWindow::closeStage2, this ) );
}

void WMainWindow::closeStage2()
{
    m_closeFirstStage = false;
    // NOTE: runs in GUI thread
    close();
}

void WMainWindow::closeEvent( QCloseEvent* e )
{
    // closing is a two-stage process. When the user requests the close, we tell the kernel to shutdown, while the GUI still is active. In the
    // second stage, we close the GUI itself (it is freezed). The kernel shutdown needs a running GUI to properly close everything -> thus we
    // ensure a running GUI in stage 1.

    // start stage stage 1
    if( !m_closeInProgress )
    {
        m_closeInProgress = true;
        m_closeFirstStage = true;

        // IMPORTANT: we tell QT to not close the app
        e->ignore();

        // show splash
        m_splash->show();
        m_splash->showMessage( "Shutting down" );
        setDisabled( true );    // avoid user interaction

        // save state
        saveWindowState();

        // tell kernel to shutdown
        m_splash->showMessage( "Shutting down kernel. Waiting for modules to finish and cleanup." );

        // start a thread for this
        m_closeStage1Thread = WThreadedRunner::SPtr( new WThreadedRunner() );
        m_closeStage1Thread->run( boost::bind( &WMainWindow::closeStage1Thread, this ) );
        return;
    }

    // stage 1 finished, close in progress -> stage 2
    if( m_closeInProgress && !m_closeFirstStage )
    {
        // now nobody accesses the osg anymore
        m_splash->showMessage( "Shutting down GUI." );

        // clean up gl widgets
        m_mainGLDock->close();
        if( m_navAxial )
        {
            m_navAxial->close();
        }
        if( m_navCoronal )
        {
            m_navCoronal->close();
        }
        if( m_navSagittal )
        {
            m_navSagittal->close();
        }

        // finally close
        e->accept();
        return;
    }

    // all other cases: user pressed "close" somewhere during shutdown
    e->ignore();
}

void WMainWindow::customEvent( QEvent* event )
{
    if( event->type() == WDeferredCallEvent::CUSTOM_TYPE )
    {
        static_cast< WDeferredCallEvent* >( event )->call();
    }
    else
    {
        // other event
        QMainWindow::customEvent( event );
    }
}

void WMainWindow::reportError( QWidget* parent, QString title, QString message )
{
    WQtMessagePopup* m = new WQtMessagePopup( parent, title, message, LL_ERROR );
    m->show();
    m_messageDock->addMessage( title, message, LL_ERROR );
}

void WMainWindow::reportWarning( QWidget* parent, QString title, QString message )
{
    WQtMessagePopup* m = new WQtMessagePopup( parent, title, message, LL_WARNING );
    m->show();
    m_messageDock->addMessage( title, message, LL_WARNING );
}

void WMainWindow::reportInfo( QWidget* parent, QString title, QString message )
{
    WQtMessagePopup* m = new WQtMessagePopup( parent, title, message, LL_INFO );
    m->show();
    m_messageDock->addMessage( title, message, LL_INFO );
}

bool WMainWindow::event( QEvent* event )
{
    // a module got associated with the root container -> add it to the list
    if( event->type() == WQT_READY_EVENT )
    {
        // convert event to ready event
        WModuleReadyEvent* e1 = dynamic_cast< WModuleReadyEvent* >( event );     // NOLINT
        if( e1 )
        {
            moduleSpecificSetup( e1->getModule() );
        }
    }

    // push the log message to the message dock
    if( event->type() == WQT_LOG_EVENT )
    {
        WLogEvent* e1 = dynamic_cast< WLogEvent* >( event );     // NOLINT
        if( e1 && getMessageDock() )
        {
            getMessageDock()->addLogMessage( e1->getEntry() );
        }
    }

    if( event->type() == WQT_CRASH_EVENT )
    {
        // convert event to ready event
        WModuleCrashEvent* e1 = dynamic_cast< WModuleCrashEvent* >( event );     // NOLINT
        if( e1 )
        {
            QString title = "Module \"" + QString::fromStdString( e1->getModule()->getName() ) + "\" caused a problem.";
            QString message = QString::fromStdString( e1->getMessage() );
            reportError( this, title, message );
        }
    }

    if( event->type() == WQT_MODULE_REMOVE_EVENT )
    {
        // convert event to ready event
        WModuleRemovedEvent* e1 = dynamic_cast< WModuleRemovedEvent* >( event );     // NOLINT
        if( e1 )
        {
            moduleSpecificCleanup( e1->getModule() );
        }
    }

    if( ( event->type() == WQT_LOADFINISHED ) && !WKernel::getRunningKernel()->isUnattendedMode() )
    {
        // convert event
        WLoadFinishedEvent* e1 = dynamic_cast< WLoadFinishedEvent* >( event );
        if( e1 )
        {
            if( e1->getErrors().size() || e1->getWarnings().size() )
            {
                size_t curErrCount = 0;
                const size_t maxErrCount = 5;
                std::string errors = "<ul>";
                for( std::vector< std::string >::const_iterator iter = e1->getErrors().begin(); iter != e1->getErrors().end(); ++iter )
                {
                    errors += "<li> " + *iter;
                    curErrCount++;

                    if( ( curErrCount == maxErrCount ) && ( e1->getErrors().size() > maxErrCount ) )
                    {
                        size_t errDiff = e1->getErrors().size() - curErrCount;
                        errors += "<li> ... and " + string_utils::toString( errDiff ) + " more errors.";
                        break;
                    }
                }
                errors += "</ul>";

                size_t curWarnCount = 0;
                const size_t maxWarnCount = 5;
                std::string warnings = "<ul>";
                for( std::vector< std::string >::const_iterator iter = e1->getWarnings().begin(); iter != e1->getWarnings().end(); ++iter )
                {
                    warnings += "<li> " + *iter;
                    curWarnCount++;

                    if( ( curWarnCount == maxWarnCount ) && ( e1->getWarnings().size() > maxWarnCount ) )
                    {
                        size_t warnDiff = e1->getWarnings().size() - curWarnCount;
                        warnings += "<li> ... and " + string_utils::toString( warnDiff ) + " more warnings.";
                        break;
                    }
                }
                warnings += "</ul>";

                if( curWarnCount && curErrCount )   // Errors and warnings
                {
                    reportError( this, "There where errors and warnings during load.",
                                             "Errors occurred during load of \"" + QString::fromStdString( e1->getFilename() ) + "\". "
                                             "The loader tried to apply as much as possible, ignoring the erroneous data. The first errors where:"
                                             + QString::fromStdString( errors ) +
                                             "Warnings occurred during load of \"" + QString::fromStdString( e1->getFilename() ) + "\". "
                                             + QString::fromStdString( warnings )
                               );
                }
                else if( curWarnCount && !curErrCount ) // only warnings
                {
                    reportWarning( this, "There where warnings during load.",
                                             "Warnings occurred during load of \"" + QString::fromStdString( e1->getFilename() ) + "\". "
                                             + QString::fromStdString( warnings )
                                 );
                }
                else if( !curWarnCount && curErrCount ) // only errors
                {
                    reportError( this, "There where errors during load.",
                                             "Errors occurred during load of \"" + QString::fromStdString( e1->getFilename() ) + "\". "
                                             "The loader tried to apply as much as possible, ignoring the erroneous data. The first errors where:"
                                             + QString::fromStdString( errors )
                               );
                }
            }
        }
    }

    return QMainWindow::event( event );
}

void WMainWindow::newRoi()
{
    // do nothing if we can not get
    WPosition crossHairPos = WKernel::getRunningKernel()->getSelectionManager()->getCrosshair()->getPosition();
    WPosition minROIPos = crossHairPos - WPosition( 10., 10., 10. );
    WPosition maxROIPos = crossHairPos + WPosition( 10., 10., 10. );

    if( m_controlPanel->getFirstRoiInSelectedBranch().get() == NULL )
    {
        osg::ref_ptr< WROIBox > newRoi = osg::ref_ptr< WROIBox >( new WROIBox( minROIPos, maxROIPos ) );
        WKernel::getRunningKernel()->getRoiManager()->addRoi( newRoi );
    }
    else
    {
        osg::ref_ptr< WROIBox > newRoi = osg::ref_ptr< WROIBox >( new WROIBox( minROIPos, maxROIPos ) );
        WKernel::getRunningKernel()->getRoiManager()->addRoi( newRoi, m_controlPanel->getFirstRoiInSelectedBranch() );
    }
}

void WMainWindow::restoreSavedState()
{
    wlog::info( "MainWindow" ) << "Restoring window state.";

    restoreGeometry( WQtGui::getSettings().value( "MainWindowGeometry", "" ).toByteArray() );
    restoreState( WQtGui::getSettings().value( "MainWindowState", "" ).toByteArray() );

    m_glDock->restoreGeometry( WQtGui::getSettings().value( "GLDockWindowGeometry", "" ).toByteArray() );
    m_glDock->restoreState( WQtGui::getSettings().value( "GLDockWindowState", "" ).toByteArray() );

    if( m_navAxial )
    {
        m_navAxial->restoreSettings();
    }
    if( m_navCoronal )
    {
        m_navCoronal->restoreSettings();
    }
    if( m_navSagittal )
    {
        m_navSagittal->restoreSettings();
    }
}

void WMainWindow::saveWindowState()
{
    wlog::info( "MainWindow" ) << "Saving window state.";

    // this saves the window state to some common location on the target OS in user scope.
    WQtGui::getSettings().setValue( "MainWindowState", saveState() );
    WQtGui::getSettings().setValue( "GLDockWindowState", m_glDock->saveState() );

    // NOTE: Qt Doc says that saveState also saves geometry. But this somehow is wrong (at least for 4.6.3)
    WQtGui::getSettings().setValue( "MainWindowGeometry", saveGeometry() );
    WQtGui::getSettings().setValue( "GLDockWindowGeometry", m_glDock->saveGeometry() );

    m_messageDock->saveSettings();
}

QSettings& WMainWindow::getSettings()
{
    return WQtGui::getSettings();
}

void WMainWindow::setSetting( std::string key, std::string value )
{
    WMainWindow::getSettings().setValue( QString::fromStdString( key ), QString::fromStdString( value ) );
}

void WMainWindow::handleLogLevelUpdate( unsigned int logLevel )
{
    WLogger::getLogger()->setDefaultLogLevel( static_cast< LogLevel >( logLevel ) );
}

void WMainWindow::handleGLVendor()
{
    // WARNING: never put blocking code here, as it might freeze the mainGLWidget.
    std::string vendor = string_utils::toLower( m_mainGLWidget->getViewer()->getOpenGLVendor() );

    // is this a mesa card?
    if( vendor.find( "mesa" ) != std::string::npos )
    {
        QString msg = "<b>Warning:</b> Your graphics card is powered by the Mesa OpenGL implementation. OpenWalnut does not support Mesa "
                      "officially, since Mesa has some severe problems with GLSL shaders. You can still use OpenWalnut, but you should be "
                      "aware that Mesa can freeze OpenWalnut. Ensure you have the latest version of Mesa installed to avoid problems.";
        QLabel* l = new QLabel( msg );
        l->setWordWrap( true );
        l->setMinimumWidth( 640 );

        WQtMessageDialog* msgDia = new WQtMessageDialog( "MesaWarning", "Mesa Warning", l, getSettings(), this );
        msgDia->show();
    }

    // is this a mesa card?
    if( ( vendor.find( "Chromium" ) != std::string::npos ) ||
        ( vendor.find( "Humper" ) != std::string::npos ) )
    {
        QString msg = "<b>Warning:</b> You seem to use OpenWalnut from inside a virtual machine. Graphics acceleration on these virtual machines"
                      " is often limited. OpenWalnut might not properly work in your setup.";
        QLabel* l = new QLabel( msg );
        l->setWordWrap( true );
        l->setMinimumWidth( 640 );

        WQtMessageDialog* msgDia = new WQtMessageDialog( "VMChromiumWarning", "Virtual Machine Warning", l, getSettings(), this );
        msgDia->show();
    }
}

void WMainWindow::showWelcomeDialog( bool force )
{
    // Load welcome file
    std::string filename( WPathHelper::getDocPath().string() + "/openwalnut-qt/OpenWalnutWelcome.html" );
    std::string content = readFileIntoString( filename );

    // gen ID for it using version (allows showing release/welcome message for each new release)
    QString msgID = "OpenWalnutWelcome" + QString( W_LIB_VERSION );

    // replace OW_VERSION
    boost::regex reg1( "%OW_LIB_VERSION%" );
    boost::regex reg2( "%OW_VERSION%" );
    content = boost::regex_replace( content, reg1, std::string( W_LIB_VERSION ) );
    content = boost::regex_replace( content, reg2, std::string( W_VERSION ) );

    QWidget* w = NULL;
    QWebView* view = new QWebView( this );
    view->setHtml( QString::fromStdString( content ) );
    view->setMinimumWidth( 640 );
    view->page()->setLinkDelegationPolicy( QWebPage::DelegateExternalLinks );
    w = view;

    WQtMessageDialog* msgDia = new WQtMessageDialog( msgID, "Welcome to OpenWalnut", w, getSettings(), this );
    msgDia->show( force );
}

void WMainWindow::handleStartMessages()
{
    // only show welcome dialog for now
    showWelcomeDialog( false );
}

void WMainWindow::handleDrop( QDropEvent* event )
{
    if( event->mimeData()->hasUrls() )
    {
        std::vector < std::string > projects;
        std::vector < std::string > filenames;
        std::vector < std::string > unsupported;
        foreach( QUrl url, event->mimeData()->urls() )
        {
            QString path =  url.toLocalFile();
            QFileInfo info( path );
            QString suffix =  info.completeSuffix();
            if( suffix == "owp" || suffix == "owproj" )
            {
                projects.push_back( path.toStdString() );
            }
            else
            {
                filenames.push_back( path.toStdString() );
            }
        }
        if( projects.size() > 0 )
        {
            for( size_t i = 0; i < projects.size(); ++i )
            {
                asyncProjectLoad( projects[ i ] );
            }
            event->accept();
        }
        if( filenames.size() > 0 )
        {
            m_loaderSignal( filenames );
            event->accept();
        }
    }
}

void WMainWindow::dropEvent( QDropEvent* event )
{
    handleDrop( event );
    QMainWindow::dropEvent( event );
}

bool WMainWindow::isDropAcceptable( const QMimeData* mimeData )
{
    return mimeData->hasUrls();
}

void WMainWindow::dragMoveEvent( QDragMoveEvent* event )
{
    if( WMainWindow::isDropAcceptable( event->mimeData() ) )
    {
        event->acceptProposedAction();
    }
    QMainWindow::dragMoveEvent( event );
}

void WMainWindow::dragEnterEvent( QDragEnterEvent* event )
{
    if( WMainWindow::isDropAcceptable( event->mimeData() ) )
    {
        event->acceptProposedAction();
    }
    QMainWindow::dragEnterEvent( event );
}

void WMainWindow::closeSplash()
{
    m_splash->finish( this );
}

QSplashScreen* WMainWindow::getSplash() const
{
    return m_splash;
}

void WMainWindow::addGlobalMenu( QWidget* widget )
{
    widget->addAction( createSeperator( this ) );
    widget->addAction( m_newAction );
    widget->addAction( m_loadButton );
    widget->addAction( m_saveAction );
    widget->addAction( createSeperator( this ) );
    widget->addAction( m_settingsAction );
    widget->addAction( createSeperator( this ) );
    widget->addAction( m_helpAction );
    widget->addAction( createSeperator( this ) );
    widget->addAction( m_quitAction );
}

const WQtMessageDock* WMainWindow::getMessageDock() const
{
    return m_messageDock;
}

WQtMessageDock* WMainWindow::getMessageDock()
{
    return m_messageDock;
}

void WMainWindow::registerCustomWidget( WUIQtWidgetBase* widget )
{
    m_customWidgets.unique_push_back( widget );
}

void WMainWindow::deregisterCustomWidget( WUIQtWidgetBase* widget )
{
    // remove
    m_customWidgets.remove( widget );
}

Qt::DockWidgetArea WMainWindow::getDefaultCustomDockArea() const
{
    return Qt::BottomDockWidgetArea;
}

QMainWindow* WMainWindow::getDefaultCustomDockAreaWidget() const
{
    return m_glDock;
}

void WMainWindow::switchVisibility( QWidget* who )
{
    who->setVisible( !who->isVisible() );
}
